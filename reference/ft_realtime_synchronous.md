---
title: ft_realtime_synchronous
---
```
 FT_REALTIME_SYNCHRONOUS is an example realtime application for
 synchronous (trigger-based) brain-computer interfaces

 Use as
   cmd = ft_realtime_synchronous(cfg)

 where cmd is the last processed command and cfg has the following configuration options
   cfg.bcifun     = the BCI function that is called
   cfg.trigger    = the trigger values that should be processed (default = 'all')
   cfg.blocksize  = number, size of the blocks/chuncks that are processed in seconds (default = 1)
   cfg.offset     = offset relative to the trigger (default = 0)
   cfg.channel    = cell-array, see FT_CHANNELSELECTION (default = 'all')
   cfg.bufferdata = whether to start on the 'first or 'last' data that is
                    available when the function _starts_ (default = 'last')
   cfg.jumptoeof  = whether to start on the 'first or 'last' data that is
                    available when the function _starts_ (default = 'last')

   cfg.ostream    = the output stream that is used to send a command via
                     write_event (default = []

 The source of the data is configured as
   cfg.dataset       = string
 or alternatively to obtain more low-level control as
   cfg.datafile      = string
   cfg.headerfile    = string
   cfg.eventfile     = string
   cfg.dataformat    = string, default is determined automatic
   cfg.headerformat  = string, default is determined automatic
   cfg.eventformat   = string, default is determined automatic

 trials that correspond to any of the triggers in the vector cfg.trigger will be
 processed. By default all trigger values will be processed (cfg.trigger =
 'all') and may be of any type (cfg.type = 'all'). The condition to which a 
 data segment belongs is passed to bcifun using cfg.condition.

 The bcifun must be of the form
   
   cmd = bcifun(cfg,data)

 where cfg is the configuration passed by this function and data is the
 new data segment. Cmd is the command which is generated by the bcifun.
 This command will be send to an external device via cfg.ostream. Check
 bcifun_latidx for an example.

 Some notes about skipping data and catching up with the data stream:

 cfg.jumptoeof='yes' causes the realtime function to jump to the end
 when the function _starts_. It causes all data acquired prior to
 starting the RT function to be skipped.
 
 cfg.bufferdata=last causes the realtime function to jump to the last
 available data while _running_. If the RT loop is not fast enough,
 it causes some data to be dropped.
 
 If you want to skip all data that was acquired before you start the
 RT function, but don't want to miss any data that was acquired while
 the realtime function is started, then you should use jumptoeof=yes and
 bufferdata=first. If you want to analyze data from a file, then you
 should use jumptoeof=no and bufferdata=first.

 To stop the realtime function, you have to press Ctrl-C
```
